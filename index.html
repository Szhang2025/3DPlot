<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>3D Function Plotter – arbitrary f(x,y)</title>
  <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/examples/js/controls/OrbitControls.min.js"></script>
  <style>
    body { margin:0; font-family: system-ui, sans-serif; background:#0d1117; color:#c9d1d9; }
    canvas { display:block; }
    #controls {
      position: absolute;
      top: 16px;
      left: 16px;
      background: rgba(22,27,34,0.92);
      backdrop-filter: blur(8px);
      padding: 18px 22px;
      border-radius: 10px;
      border: 1px solid #30363d;
      box-shadow: 0 6px 30px rgba(0,0,0,0.65);
      z-index: 200;
      width: 340px;
    }
    input[type="text"] {
      width: 100%;
      padding: 10px 14px;
      margin: 12px 0 16px 0;
      background: #161b22;
      color: #e6edf3;
      border: 1px solid #444c56;
      border-radius: 6px;
      font-family: 'Consolas', 'Courier New', monospace;
      font-size: 15px;
    }
    button {
      padding: 9px 20px;
      background: #238636;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
    }
    button:hover { background: #2ea043; }
    .help {
      margin-top: 14px;
      font-size: 13px;
      color: #8b949e;
      line-height: 1.45;
    }
    h2 { margin: 0 0 12px 0; font-size: 1.4rem; color: #58a6ff; }
  </style>
</head>
<body>

<div id="controls">
  <h2>z = f(x, y)</h2>
  <input type="text" id="expr" value="Math.sin(Math.sqrt(x*x + y*y)) * Math.cos(x*1.4 + y)" 
         placeholder="examples below →"/>
  <button onclick="rebuild()">Plot / Update</button>

  <div class="help">
    <strong>Drag</strong> = rotate &nbsp; • &nbsp;
    <strong>Scroll</strong> / pinch = zoom &nbsp; • &nbsp;
    <strong>Right drag</strong> = pan<br><br>

    <strong>Allowed:</strong> x, y, Math.sin/cos/tan/exp/log/sqrt/pow/abs/min/max,<br>
    ** (power), ? : (ternary), numbers, parentheses...<br><br>

    <strong>Try these:</strong><br>
    • x**2 + y**2<br>
    • Math.sin(x*5) * Math.cos(y*5)<br>
    • Math.exp(-0.1*(x*x+y*y)) * Math.sin(x*8)<br>
    • (x>0 ? y : -y) * Math.sin(x*6)<br>
    • Math.hypot(x,y) * Math.sin(Math.hypot(x,y)*4)<br>
    • Math.tan(x+y) / (1 + x*x + y*y)
  </div>
</div>

<script>
// ───────────────────────────────────────────────────────────────
const scene  = new THREE.Scene();
scene.background = new THREE.Color(0x0d1117);

const camera = new THREE.PerspectiveCamera(65, innerWidth/innerHeight, 0.1, 400);
camera.position.set(14, 11, 22);

const renderer = new THREE.WebGLRenderer({antialias:true, powerPreference:"high-performance"});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(window.devicePixelRatio * 1.1);
document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.085;
controls.rotateSpeed = 0.75;
controls.zoomSpeed = 1.15;

// ─── Lighting ────────────────────────────────────────────────────
scene.add(new THREE.AmbientLight(0xffffff, 0.52));
const dirLight = new THREE.DirectionalLight(0xffffff, 1.35);
dirLight.position.set(10, 18, 12);
scene.add(dirLight);

// ─── Surface ─────────────────────────────────────────────────────
let surface = null;

function rebuild() {
  const code = document.getElementById('expr').value.trim();
  if (!code) return;

  // Clean up previous mesh
  if (surface) {
    scene.remove(surface);
    surface.geometry.dispose();
    surface.material.dispose();
    surface = null;
  }

  const geometry = new THREE.BufferGeometry();
  const vertices = [];
  const colors = [];

  const segs   = 96;           // resolution (higher = smoother, slower)
  const size   = 7.5;          // x,y range: -size … +size
  const step   = (size * 2) / segs;

  // Create safe evaluator
  let evaluate;
  try {
    evaluate = new Function('x', 'y', `
      "use strict";
      const MathObj = Math;
      return (${code});
    `);
  } catch (err) {
    alert("Cannot understand expression:\n" + err.message);
    return;
  }

  let zMin = Infinity, zMax = -Infinity;

  for (let i = 0; i <= segs; i++) {
    for (let j = 0; j <= segs; j++) {
      const x = -size + i * step;
      const y = -size + j * step;

      let z = 0;
      try {
        z = evaluate(x, y);
        if (typeof z !== 'number' || !isFinite(z)) z = 0;
      } catch {
        z = 0;
      }

      zMin = Math.min(zMin, z);
      zMax = Math.max(zMax, z);

      vertices.push(x, y, z);

      // Color based on height (blue → cyan → green → yellow → red)
      const t = (zMin === zMax) ? 0.5 : (z - zMin) / (zMax - zMin);
      let r = 0, g = 0, b = 0;
      if (t < 0.25)      { b = 1; g = t*4; }
      else if (t < 0.5)  { b = 1-(t-0.25)*4; g = 1; }
      else if (t < 0.75) { g = 1; r = (t-0.5)*4; }
      else               { g = 1-(t-0.75)*4; r = 1; }

      colors.push(r, g, b);
    }
  }

  // Triangles
  const indices = [];
  for (let i = 0; i < segs; i++) {
    for (let j = 0; j < segs; j++) {
      const a =  i       *(segs+1) + j;
      const b =  i       *(segs+1) + j + 1;
      const c = (i + 1)  *(segs+1) + j;
      const d = (i + 1)  *(segs+1) + j + 1;
      indices.push(a, b, d, a, d, c);
    }
  }

  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('color',    new THREE.Float32BufferAttribute(colors, 3));
  geometry.setIndex(indices);
  geometry.computeVertexNormals();

  const material = new THREE.MeshStandardMaterial({
    vertexColors: true,
    side: THREE.DoubleSide,
    roughness: 0.68,
    metalness: 0.12,
    flatShading: false
  });

  surface = new THREE.Mesh(geometry, material);
  scene.add(surface);

  // Auto-adjust view
  const zHeight = zMax - zMin || 1;
  const targetY = (zMin + zMax) / 2;
  controls.target.set(0, targetY, 0);
  const dist = Math.max(16, size * 1.9 + zHeight * 0.7);
  camera.position.set(dist*0.65, dist*0.5 + targetY, dist*0.8);
  controls.update();
}

// ─── Start ───────────────────────────────────────────────────────
window.addEventListener('load', rebuild);

window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
