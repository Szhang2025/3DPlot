<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>3D Function Plotter – z = f(x,y)</title>

  <!-- Use official Three.js CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r182/three.min.js"></script>
  <!-- Separate OrbitControls -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.182.0/examples/js/controls/OrbitControls.min.js"></script>

  <style>
    body { margin:0; font-family: system-ui, sans-serif; background:#0d1117; color:#c9d1d9; overflow:hidden; }
    canvas { display:block; }
    #gui {
      position: absolute;
      top: 16px;
      left: 16px;
      background: rgba(22,27,34,0.9);
      backdrop-filter: blur(8px);
      padding: 18px 22px;
      border-radius: 10px;
      border: 1px solid #30363d;
      box-shadow: 0 6px 30px #00000088;
      z-index: 200;
      width: 340px;
    }
    input[type="text"] {
      width: 100%;
      padding: 10px 14px;
      margin: 12px 0 16px 0;
      background: #161b22;
      color: #e6edf3;
      border: 1px solid #444c56;
      border-radius: 6px;
      font-family: Consolas, monospace;
      font-size: 15px;
    }
    button {
      padding: 9px 20px;
      background: #238636;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
    }
    button:hover { background: #2ea043; }
    .help {
      margin-top: 14px;
      font-size: 13px;
      color: #8b949e;
      line-height: 1.45;
    }
    h2 { margin: 0 0 12px; font-size: 1.4rem; color: #58a6ff; }
  </style>
</head>
<body>

<div id="gui">
  <h2>z = f(x, y)</h2>
  <input type="text" id="expr" value="Math.sin(Math.hypot(x,y)*5)" 
         placeholder="Math.sin(x*5) * Math.cos(y*5)"/>
  <button onclick="rebuild()">Plot / Update</button>

  <div class="help">
    <strong>Left drag</strong> → rotate<br>
    <strong>Scroll / pinch</strong> → zoom<br>
    <strong>Right drag / Middle drag</strong> → pan<br><br>

    Use: x, y, Math.sin/cos/tan/exp/log/sqrt/pow/abs/min/max/hypot/** etc.<br><br>

    Try:<br>
    • x**2 + y**2<br>
    • Math.sin(x*8) * Math.cos(y*8)<br>
    • Math.exp(-0.12*(x*x + y*y)) * Math.sin(x*10 + y*4)<br>
    • (x > y ? 1 : -1) * Math.hypot(x,y)<br>
    • Math.atan2(y,x) * 4 + Math.sin(Math.hypot(x,y)*6)
  </div>
</div>

<script>
// Make functions global
window.rebuild = rebuild;

// ───────────────────────────────────────────────────────────────
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0d1117);

const camera = new THREE.PerspectiveCamera(65, window.innerWidth/window.innerHeight, 0.1, 500);
camera.position.set(12, 10, 18);

const renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.09;
controls.rotateSpeed = 0.8;
controls.zoomSpeed = 1.2;

// Lights
scene.add(new THREE.AmbientLight(0xffffff, 0.55));
const dirLight = new THREE.DirectionalLight(0xffffff, 1.4);
dirLight.position.set(12, 20, 15);
scene.add(dirLight);

// ─── Surface mesh ────────────────────────────────────────────────
let mesh = null;

function rebuild() {
  const expr = document.getElementById('expr').value.trim();
  if (!expr) return;

  // Cleanup old mesh
  if (mesh) {
    scene.remove(mesh);
    mesh.geometry.dispose();
    mesh.material.dispose();
  }

  const geometry = new THREE.BufferGeometry();
  const positions = [];
  const colors = [];

  const segments = 100;
  const halfSize = 8;
  const step = (halfSize * 2) / segments;

  // Safe function evaluator
  let func;
  try {
    // Create a function that evaluates the expression
    func = new Function('x', 'y', `return ${expr}`);
  } catch (e) {
    alert("Invalid expression:\n" + e.message);
    return;
  }

  let zMin = Infinity, zMax = -Infinity;

  // First pass: collect positions and find min/max z
  for (let i = 0; i <= segments; i++) {
    for (let j = 0; j <= segments; j++) {
      const x = -halfSize + i * step;
      const y = -halfSize + j * step;
      let z = 0;
      try {
        z = func(x, y);
        if (typeof z !== 'number' || !isFinite(z)) z = 0;
      } catch (err) {
        z = 0;
      }
      positions.push(x, y, z);
      zMin = Math.min(zMin, z);
      zMax = Math.max(zMax, z);
    }
  }

  // Second pass: assign colors based on normalized z values
  for (let i = 0; i < positions.length; i += 3) {
    const z = positions[i + 2];
    const norm = (zMin === zMax) ? 0.5 : (z - zMin) / (zMax - zMin);
    
    let r=0, g=0, b=0;
    if (norm < 0.2) {
      r = 0;
      g = norm * 5;
      b = 1;
    } else if (norm < 0.4) {
      r = 0;
      g = 1;
      b = 1 - (norm - 0.2) * 5;
    } else if (norm < 0.6) {
      r = (norm - 0.4) * 5;
      g = 1;
      b = 0;
    } else if (norm < 0.8) {
      r = 1;
      g = 1 - (norm - 0.6) * 5;
      b = 0;
    } else {
      r = 1;
      g = 0;
      b = (norm - 0.8) * 5;
    }
    
    colors.push(r, g, b);
  }

  // Build faces
  const indices = [];
  for (let i = 0; i < segments; i++) {
    for (let j = 0; j < segments; j++) {
      const a = i * (segments + 1) + j;
      const b = i * (segments + 1) + (j + 1);
      const c = (i + 1) * (segments + 1) + j;
      const d = (i + 1) * (segments + 1) + (j + 1);
      indices.push(a, b, d);
      indices.push(a, d, c);
    }
  }

  geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
  geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
  geometry.setIndex(indices);
  geometry.computeVertexNormals();

  const material = new THREE.MeshStandardMaterial({
    vertexColors: true,
    side: THREE.DoubleSide,
    roughness: 0.65,
    metalness: 0.1
  });

  mesh = new THREE.Mesh(geometry, material);
  scene.add(mesh);

  // Center & scale view
  const zRange = zMax - zMin || 10;
  controls.target.set(0, (zMin + zMax) / 2, 0);
  const dist = Math.max(20, halfSize * 2.2 + zRange * 0.9);
  camera.position.set(dist * 0.7, dist * 0.55, dist * 0.85);
  controls.update();
}

// ─── Init & loop ─────────────────────────────────────────────────
window.addEventListener('load', () => {
  rebuild();
});

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
